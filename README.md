## Домашнее задание 7

### Описание
В рамках задания мы разрабатываем новый сервис-витрину заказов. Такие сервисы обычно используются в качестве read-моделей, которые позволяют снизить нагрузку на операционную БД, сделать данные более доступными, обогатить информацией с других сервисов и обеспечить более высокие сроки хранения информации. Все это накладывает на них определенные ограничения, например:
- более сложная инфраструктура
- асинхронное взаимодействие с мастер-системами.

Задача разрабатываемой витрины:
- собрать информацию по заказу на основе событий (элемент доп задания)
- сохранить ее в шардированной БД

### Основное задание
Основная часть задания сводится к тому, что нужно:
- развернуть инфраструктуру с шардированными БД
- создать новый сервис
- реализовать механизм миграций схем и данных в шардированной инфраструктуре
- реализовать DAL (data access layer) слой, который через репозитории позволит сохранять и получать данные из шардированной БД

#### Требования
1. Нужно разработать новый сервис **view-order-service**, учесть возможность задания настроек через переменные окружения
3. Сервис должен иметь 2 сервера БД (строки подключения из переменных окружения)
   - **view-order-service-db-shard-1**
   - **view-order-service-db-shard-2**
3. Общее количество бакетов 10, в каждом шарде по 5 бакетов.
4. В каждом бакете должна быть таблица **orders** с полями:
   - OrderId - bigint - уникальный идентификатор заказа
   - RegionId - bigint - идентификатор региона заказа
   - Status - int - актуальный статус заказа
   - CustomerId - bigint - уникальный идентификатор заказчика
   - Comment - text - комментарий по заказу
   - CreatedAt - tz - дата создания заказа UTC
5. Таблица **orders** должна накатываться по бакетам миграцией через FluentMigrator
6. Ключ шардирования - идентификатор заказа (`order_id`)
7. Для работы с БД использовать Dapper
8. Необходимые методы репозитория
8.1. Метод вставки данных заказа в нужный бакет (в соответствии с набором полей п.4)
8.2. Метод обновления данных заказа в нужном бакете по идентификатору заказа (в соответствии с набором полей п.4)
8.3. Метод получения списка заказов (возвращать набор полей п.4) по: 
8.3.1. набору идентификаторов заказов 
8.3.2. набору идентификаторов регионов
8.3.3. набору идентификаторов заказчиков
8.3.4. диапазону строк выборки (limit/offset)
9. Для вставки и обновления данных необходимо использовать пользовательские типы данных, которые должны быть только в public-схеме каждого шарда.
10. Должны быть написаны интеграционные тесты на методы репозитория (п.8), проверяющие happy-path сценарии для операций вставки и обновления, а также корректность фильтрации в выборке (п.8.3)


#### Настройки сервиса

Настройки можно указать через переменные окружения.

##### Строка подключения к серверу БД №1
Название переменной окружения: `ROUTE256_VIEW_ORDER_SERVICE_DB_SHARD1_CONNECTION_STRINGS`
Допустимые значения (строка)

##### Строка подключения к серверу БД №2
Название переменной окружения: `ROUTE256_VIEW_ORDER_SERVICE_DB_SHARD2_CONNECTION_STRINGS`
Допустимые значения (строка)

##### Количество бакетов на сервере
Название переменной окружения: `ROUTE256_VIEW_ORDER_SERVICE_DB_BUCKETS_PER_SHARD`
Допустимые значения 1-100 (по умолчанию - 3)

##### Адреса брокеров Kafka
Название переменной окружения: `ROUTE256_KAFKA_BROKERS`
Допустимые значения (строка)
Список адресов хостов брокеров Kafka, разделенных через запятую


### Дополнительное задание
Дополнительное задание - добавить слой бизнес-логики, который:
- получает события по заказу из топика **order_output_events**
- сохраняет текущее состояние заказа в шардированной БД

#### Требования
1. Необходимо сделать консьюмер топика **order_output_events** и получить актуальный снэпшот заказов из **V1QueryOrders** сервиса **order-service**
2. Сохранять заказы в шардированной БД с использованием методов репозитория
3. Должны быть написаны Unit-тесты на обработку сообщения из топика, покрывающие happy-path сценарии и exсeption-path сценарии (подсказка, лучше инфраструктурные особенности - как консьюмить оставить без тестов, но логику, что происходит в результате обработки сообщения, покрыть тестами)

### Дедлайны сдачи и проверки задания: 
- 12 апреля 23:59 (сдача) / 15 апреля, 23:59 (проверка)
